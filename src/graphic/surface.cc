/*
 * Copyright (C) 2006-2013 by the Widelands Development Team
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

#include "graphic/surface.h"

#include <cassert>
#include <cmath>
#include <cstdlib>

#include <SDL.h>

#include "base/macros.h"
#include "base/point.h"
#include "base/rect.h"
#include "graphic/gl/coordinate_conversion.h"
#include "graphic/gl/utils.h"
#include "graphic/line_draw_mode.h"

namespace {

// This is for drawing the line-joint circles.
// The x and y values are generated by this python code:
// from math import *
// x, y = [], []
// for i in range(kNumTrianglesForCircle):
//   x.append(math.cos(2*pi*float(i)/kNumTrianglesForCircle))
//   y.append(math.sin(2*pi*float(i)/kNumTrianglesForCircle))
constexpr int kNumTrianglesForCircle = 5;
constexpr float kCircleXValues[kNumTrianglesForCircle] = {
   1.f, 0.30901699f, -0.80901699f, -0.80901699f, 0.30901699f,
};
constexpr float kCircleYValues[kNumTrianglesForCircle] = {
   0.f, 0.95105652f, 0.58778525f, -0.58778525f, -0.95105652f,
};

// Adjust 'original' so that only 'src_rect' is actually blitted.
BlitData adjust_for_src(BlitData blit_data, const Rect& src_rect) {
	blit_data.rect.x += src_rect.x;
	blit_data.rect.y += src_rect.y;
	blit_data.rect.w = src_rect.w;
	blit_data.rect.h = src_rect.h;
	return blit_data;
}

// Get the normal of the line between 'start' and 'end'.
template <typename PointType>
FloatPoint calculate_line_normal(const PointType& start, const PointType& end) {
	const float dx = end.x - start.x;
	const float dy = end.y - start.y;
	const float len = std::hypot(dx, dy);
	return FloatPoint(-dy / len, dx / len);
}

// Tesselates the line made up of 'points' ino triangles and converts them into OpenGL space for a
// renderbuffer of dimensions 'w' and 'h'.
void tesselate_line_strip(const int w,
                          const int h,
                          const RGBAColor& color,
                          float line_width,
                          const std::vector<Point>& points,
                          std::vector<DrawLineProgram::PerVertexData>* vertices) {

	const float r = color.r / 255.;
	const float g = color.g / 255.;
	const float b = color.b / 255.;
	const float a = color.a / 255.;

	// Iterate over each line segment, i.e. all points but the last, convert
	// them from pixel space to gl space and draw them.
	for (size_t i = 0; i < points.size() - 1; ++i) {
		const FloatPoint p1 = FloatPoint(points[i].x, points[i].y);
		const FloatPoint p2 = FloatPoint(points[i + 1].x, points[i + 1].y);
		const FloatPoint normal = calculate_line_normal(p1, p2);
		const FloatPoint scaled_n(0.5 * line_width * normal.x, 0.5 * line_width * normal.y);

		// Quad points are created in rendering order for OpenGL.
		FloatPoint quad_a = p1 - scaled_n;
		pixel_to_gl_renderbuffer(w, h, &quad_a.x, &quad_a.y);
		vertices->emplace_back(DrawLineProgram::PerVertexData{quad_a.x, quad_a.y, 0.f, r, g, b, a});

		FloatPoint quad_b = p2 - scaled_n;
		pixel_to_gl_renderbuffer(w, h, &quad_b.x, &quad_b.y);
		vertices->emplace_back(DrawLineProgram::PerVertexData{quad_b.x, quad_b.y, 0.f, r, g, b, a});

		FloatPoint quad_c = p1 + scaled_n;
		pixel_to_gl_renderbuffer(w, h, &quad_c.x, &quad_c.y);
		vertices->emplace_back(DrawLineProgram::PerVertexData{quad_c.x, quad_c.y, 0.f, r, g, b, a});

		vertices->push_back(vertices->at(vertices->size() - 2));
		vertices->push_back(vertices->at(vertices->size() - 2));

		FloatPoint quad_d = p2 + scaled_n;
		pixel_to_gl_renderbuffer(w, h, &quad_d.x, &quad_d.y);
		vertices->emplace_back(DrawLineProgram::PerVertexData{quad_d.x, quad_d.y, 0.f, r, g, b, a});
	}

	// Draw a circle around each point, to join the disjunct lines together.
	// Since Widelands only uses very thin lines, a circle with 5 triangles does
	// not look worse than one using 60.
	for (size_t i = 0; i < points.size(); ++i) {
		const FloatPoint p1 = FloatPoint(points[i].x, points[i].y);
		for (int j = 0; j < kNumTrianglesForCircle; ++j) {
			float x1 = p1.x + 0.5 * line_width * kCircleXValues[j];
			float x2 = p1.x + 0.5 * line_width * kCircleXValues[(j + 1) % kNumTrianglesForCircle];
			float y1 = p1.y + 0.5 * line_width * kCircleYValues[j];
			float y2 = p1.y + 0.5 * line_width * kCircleYValues[(j + 1) % kNumTrianglesForCircle];
			float x = p1.x;
			float y = p1.y;
			pixel_to_gl_renderbuffer(w, h, &x1, &y1);
			pixel_to_gl_renderbuffer(w, h, &x2, &y2);
			pixel_to_gl_renderbuffer(w, h, &x, &y);

			vertices->emplace_back(DrawLineProgram::PerVertexData{x, y, 0.f, r, g, b, a});
			vertices->emplace_back(DrawLineProgram::PerVertexData{x1, y1, 0.f, r, g, b, a});
			vertices->emplace_back(DrawLineProgram::PerVertexData{x2, y2, 0.f, r, g, b, a});
		}
	}
}

}  // namespace

void draw_rect(const Rect& rc, const RGBColor& clr, Surface* surface) {
	surface->draw_line_strip({
		Point(rc.x, rc.y),
		Point(rc.x + rc.w, rc.y),
		Point(rc.x + rc.w, rc.y + rc.h),
		Point(rc.x, rc.y + rc.h),
		Point(rc.x, rc.y),
	}, clr, 1, LineDrawMode::kSharp);
}

void Surface::fill_rect(const Rect& rc, const RGBAColor& clr) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), rc);
	do_fill_rect(rect, clr, BlendMode::Copy);
}

void Surface::brighten_rect(const Rect& rc, const int32_t factor)
{
	if (!factor) {
		return;
	}

	const BlendMode blend_mode = factor < 0 ? BlendMode::Subtract : BlendMode::UseAlpha;
	const int abs_factor = std::abs(factor);
	const RGBAColor color(abs_factor, abs_factor, abs_factor, 0);
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), rc);
	do_fill_rect(rect, color, blend_mode);
}

void Surface::draw_line_strip(std::vector<Point> points,
                              const RGBColor& color,
                              float line_width,
                              const LineDrawMode& line_draw_mode) {
	if (points.size() < 2) {
		return;
	}

	std::vector<DrawLineProgram::PerVertexData> vertices;
	// We need for each point the number of triangles for the circle around it 2
	// more triangles for the line to the next point. A triangle has 3 points.
	vertices.reserve(3 * points.size() * (kNumTrianglesForCircle + 2));

	const auto w = width();
	const auto h = height();
	// TODO(sirver): This code relies on depth testing to not draw
	// semi-transparent pixels twice. That also means that kAntialiased will not
	// perform correctly when drawing on offscreen surfaces - which we never do
	// for lines in Widelands.
	tesselate_line_strip(
	   w, h, RGBAColor(color.r, color.g, color.b, 255), line_width, points, &vertices);
	if (line_draw_mode == LineDrawMode::kAntialiased) {
		tesselate_line_strip(w, h, RGBAColor(color.r, color.g, color.b, 52), line_width + 2., points,
		                     &vertices);
	}
	do_draw_line_strip(std::move(vertices));
}

void Surface::blit_monochrome(const Rect& dst_rect,
                              const Image& image,
                              const Rect& src_rect,
                              const RGBAColor& blend) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit_monochrome(rect, adjust_for_src(image.blit_data(), src_rect), blend);
}

void Surface::blit_blended(const Rect& dst_rect,
                           const Image& image,
                           const Image& texture_mask,
                           const Rect& src_rect,
                           const RGBColor& blend) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit_blended(rect, adjust_for_src(image.blit_data(), src_rect),
	                adjust_for_src(texture_mask.blit_data(), src_rect), blend);
}

void Surface::blit(const Rect& dst_rect,
                   const Image& image,
                   const Rect& src_rect,
                   float opacity,
                   BlendMode blend_mode) {
	const FloatRect rect = rect_to_gl_renderbuffer(width(), height(), dst_rect);
	do_blit(rect, adjust_for_src(image.blit_data(), src_rect), opacity, blend_mode);
}
